--!strict
-- ROBLOX upstream: https://github.com/facebook/react/blob/ddd1faa1972b614dfbfae205f2aa4a6c0b39a759/packages/react/src/ReactHooks.js
--[[*
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
]]

local LuauPolyfill = require(script.Parent.Parent.Parent:WaitForChild('.luau-aliases'):WaitForChild('@jsdotlua'):WaitForChild('luau-polyfill'))
local Array = LuauPolyfill.Array
type Array<T> = LuauPolyfill.Array<T>
-- ROBLOX: use patched console from shared
local console = require(script.Parent.Parent.Parent:WaitForChild('.luau-aliases'):WaitForChild('@jsdotlua'):WaitForChild('shared')).console

local ReactTypes = require(script.Parent.Parent.Parent:WaitForChild('.luau-aliases'):WaitForChild('@jsdotlua'):WaitForChild('shared'))-- ROBLOX TODO: we only pull in Dispatcher here for the typecheck, remove once Luau narrowing improves

type Dispatcher = ReactTypes.Dispatcher
type MutableSource<T> = ReactTypes.MutableSource<T>
type MutableSourceGetSnapshotFn<Source, Snapshot> = ReactTypes.MutableSourceGetSnapshotFn<
	Source,
	Snapshot
>
type MutableSourceSubscribeFn<Source, Snapshot> = ReactTypes.MutableSourceSubscribeFn<
	Source,
	Snapshot
>
type ReactProviderType<T> = ReactTypes.ReactProviderType<T>
type ReactContext<T> = ReactTypes.ReactContext<T>
local ReactFiberHostConfig = require(script.Parent.Parent.Parent:WaitForChild('.luau-aliases'):WaitForChild('@jsdotlua'):WaitForChild('shared'))
type OpaqueIDType = ReactFiberHostConfig.OpaqueIDType

-- local invariant = require("@pkg/@jsdotlua/shared").invariant

local ReactCurrentDispatcher =
	require(script.Parent.Parent.Parent:WaitForChild('.luau-aliases'):WaitForChild('@jsdotlua'):WaitForChild('shared')).ReactSharedInternals.ReactCurrentDispatcher

type BasicStateAction<S> = ((S) -> S) | S
type Dispatch<A> = (A) -> ()

-- ROBLOX FIXME Luau: we shouldn't need to explicitly annotate this
local function resolveDispatcher(): Dispatcher
	local dispatcher = ReactCurrentDispatcher.current
	-- Will result in a null access error if accessed outside render phase. We
	-- intentionally don't throw our own error because this is in a hot path.
	-- Also helps ensure this is inlined.
	












return dispatcher :: Dispatcher
end

local exports = {}

local function useContext<T>(
	Context: ReactContext<T>,
	unstable_observedBits: number | boolean | nil,
	... -- ROBLOX deviation: Lua must specify ... here to capture additional args
): T
	local dispatcher = resolveDispatcher()
	






























return dispatcher.useContext(Context, unstable_observedBits)
end
exports.useContext = useContext

local function useState<S>(
	initialState: (() -> S) | S,
	...
): (S, Dispatch<BasicStateAction<S>>)
	local dispatcher = resolveDispatcher()
	return dispatcher.useState(initialState, ...)
end
exports.useState = useState

local function useReducer<S, I, A>(
	reducer: (S, A) -> S,
	initialArg: I,
	init: ((I) -> S)?
): (S, Dispatch<A>)
	local dispatcher = resolveDispatcher()
	return dispatcher.useReducer(reducer, initialArg, init)
end
exports.useReducer = useReducer

-- ROBLOX TODO: reconciling this with bindings and sharing any relevant Ref types (there may be different ones depending on whether it's just a loose ref, vs one being assigned to the ref prop
local function useRef<T>(initialValue: T): { current: T }
	local dispatcher = resolveDispatcher()
	return dispatcher.useRef(initialValue)
end
exports.useRef = useRef

-- ROBLOX deviation START: Bindings are a feature unique to Roact
local function useBinding<T>(
	initialValue: T
): (
	ReactTypes.ReactBinding<T>,
	ReactTypes.ReactBindingUpdater<T>
)
	local dispatcher = resolveDispatcher()
	return dispatcher.useBinding(initialValue)
end
exports.useBinding = useBinding
-- ROBLOX deviation END

local function useEffect(
	-- ROBLOX TODO: Luau needs union type packs for this type to translate idiomatically
	create: (() -> ()) | (() -> (() -> ())),
	deps: Array<any> | nil
): ()
	local dispatcher = resolveDispatcher()
	return dispatcher.useEffect(create, deps)
end
exports.useEffect = useEffect

local function useLayoutEffect(
	-- ROBLOX TODO: Luau needs union type packs for this type to translate idiomatically
	create: (() -> ()) | (() -> (() -> ())),
	deps: Array<any> | nil
): ()
	local dispatcher = resolveDispatcher()
	return dispatcher.useLayoutEffect(create, deps)
end
exports.useLayoutEffect = useLayoutEffect

local function useCallback<T>(callback: T, deps: Array<any> | nil): T
	local dispatcher = resolveDispatcher()
	return dispatcher.useCallback(callback, deps)
end
exports.useCallback = useCallback

local function useMemo<T...>(create: () -> T..., deps: Array<any> | nil): T...	
local dispatcher = resolveDispatcher()
	return dispatcher.useMemo(create, deps)
end
exports.useMemo = useMemo

local function useImperativeHandle<T>(
	ref: { current: T | nil } | ((inst: T | nil) -> any) | nil,
	create: () -> T,
	deps: Array<any> | nil
): ()
	local dispatcher = resolveDispatcher()
	return dispatcher.useImperativeHandle(ref, create, deps)
end
exports.useImperativeHandle = useImperativeHandle

local function useDebugValue<T>(value: T, formatterFn: ((value: T) -> any)?): ()

	-- deviation: return nil explicitly for safety
	



return nil
end
exports.useDebugValue = useDebugValue

exports.emptyObject = {}

-- ROBLOX TODO: enable useTransition later
-- exports.useTransition = function(): ((() -> ()) -> (), boolean)
-- 	local dispatcher = resolveDispatcher()
-- 	return dispatcher.useTransition()
-- end

-- ROBLOX TODO: enable useDeferredValue later
-- exports.useDeferredValue = function<T>(value: T): T
-- 	local dispatcher = resolveDispatcher()
-- 	return dispatcher.useDeferredValue(value)
-- end

exports.useOpaqueIdentifier = function(): OpaqueIDType | nil
	local dispatcher = resolveDispatcher()
	return dispatcher.useOpaqueIdentifier()
end

exports.useMutableSource =
	function<Source, Snapshot>(
		source: MutableSource<Source>,
		getSnapshot: MutableSourceGetSnapshotFn<Source, Snapshot>,
		subscribe: MutableSourceSubscribeFn<Source, Snapshot>
	): Snapshot
		local dispatcher = resolveDispatcher()
		return dispatcher.useMutableSource(source, getSnapshot, subscribe)
	end

return exports
